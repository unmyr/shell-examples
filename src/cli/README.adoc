## Filter

* Filter stdout
+
[source,shell]
----
(echo "error1 error2" | tr ' ' '\n' 1>&2; echo "info1 info2" | tr ' ' '\n') 1> >(grep 2)
----
+
[source,plaintext]
----
$ (echo "error1 error2" | tr ' ' '\n' 1>&2; echo "info1 info2" | tr ' ' '\n') 1> >(grep 2)
error1
error2
info2
----

* Filter stderr
+
[source,shell]
----
(echo "error1 error2" | tr ' ' '\n' 1>&2; echo "info1 info2" | tr ' ' '\n') 2> >(grep 2)
----
+
[source,plaintext]
----
$ (echo "error1 error2" | tr ' ' '\n' 1>&2; echo "info1 info2" | tr ' ' '\n') 2> >(grep 2)
error2
info1
info2
----

* `piping_stderr_1.sh`
+
[source,plaintext]
----
$ ./piping_stderr_1.sh 
INFO: TTY=/dev/pts/4
TRACE: 1: 1(/proc/183263/fd/pipe:[3470331]) 2(/dev/pts/4) 3(/proc/183267/fd/3): fds=[0, 1, 19, 2, 20, 22, 3]
INFO: No fatal error occurred
INFO: The xyz service recovered automatically
  ERROR: *Fatal* error
  TRACE: 2a: 1(/proc/183275/fd/pipe:[3470885]) 2(/proc/183277/fd/pipe:[3471372]) 3(/proc/183279/fd/3): fds=[0, 1, 19, 2, 20, 22, 3]
  TRACE: 2b: 1(/proc/183284/fd/pipe:[3470905]) 2(/dev/pts/4) 3(/proc/183288/fd/3): fds=[0, 1, 19, 2, 20, 22, 3]
TRACE: 2c: 1(/proc/183291/fd/pipe:[3470915]) 2(/dev/pts/4) 3(/dev/pts/4): fds=[0, 1, 19, 2, 20, 22, 3, 4]
TRACE: 3: 1(/proc/183298/fd/pipe:[3471423]) 2(/dev/pts/4) 3(/proc/183302/fd/3): fds=[0, 1, 19, 2, 20, 22, 3]
----


## File descriptor examples

* Open/Close file descriptor
+
[source,shell]
.file_descriptor_example.sh
----
exec 5<<EOF
apple
cherry
banana
EOF

while read -r -u 5 LINE; do
    echo "Read from file descriptor 5: $LINE"
done

exec 5>&-
----
+
[source,plaintext]
----
$ ./file_descriptor_example.sh 
INFO: Before the file descriptor is opened: 0, 1, 19, 2, 21, 22, 23, 24, 3
INFO: Open file descriptor 5.
INFO: After the file descriptor 5 is open: 0, 1, 19, 2, 21, 22, 23, 24, 3, 5
INFO: realpath /proc/self/fd/5 -> /proc/62034/fd/pipe:[1239468]
INFO: test -p /proc/self/fd/5 -> 0
Read from file descriptor 5: apple
Read from file descriptor 5: cherry
Read from file descriptor 5: banana
INFO: Close file descriptor 5.
INFO: After the file descriptor 5 is closed: 0, 1, 19, 2, 21, 22, 23, 24, 3
----

## Redirect from stdin

* Example 1: `cat <&0`
+
[source,shell]
----
bash -c 'cat <&0' < <(printf "apple\nbanana\ncherry\n")
----
+
[source,plaintext]
----
apple
banana
cherry
----

* Example 2: `cat -`
+
[source,shell]
----
bash -c 'cat -' < <(printf "apple\nbanana\ncherry\n")
----
+
[source,plaintext]
----
apple
banana
cherry
----

### Multiple inputs

* Example 1
+
[source,plaintext]
----
$ diff <(printf "apple\nbanana\ncherry\n") <(printf "apple\ncherry\n")
2d1
< banana
----

* Example 2
+
[source,shell]
----
bash <(echo '#!/usr/bin/env bash'; echo 'echo "BASH_SOURCE: $BASH_SOURCE, \$0: $0, ARGC: $#, ARGS: $@"') <(echo "apple") <(echo "banana peach" | tr ' ' '\n')
----
+
[source,plaintext]
.Results
----
BASH_SOURCE: /dev/fd/63, $0: /dev/fd/63, ARGC: 2, ARGS: /dev/fd/62 /dev/fd/61
----

* Example 3
+
[source,shell]
----
bash show_args.sh <(echo "apple") <(echo "banana peach" | tr ' ' '\n')
----
+
[source,shell]
.show_args.sh
----
#!/usr/bin/env bash
echo "ARGC: $#"
echo "ARGS: $@"

for STDIN in "$@"; do
    (set -x; cat $STDIN)
done
----
+
[source,plaintext]
.Results
----
$ bash ./src/stdin/redirects_from_stdin.sh 
ARGC: 2
ARGS: /dev/fd/63 /dev/fd/62
+ cat /dev/fd/63
apple
+ cat /dev/fd/62
banana
peach
----

* Example 4: `loop_from_stdin.sh`
+
[source,plaintext]
----
$ bash src/stdin/loop_from_stdin.sh 
--- Read lines from stdin ---
[2024-12-28T08:08:27+09:00 ]: INFO: ARGC=0, ARGS=[]
[2024-12-28T08:08:27+09:00 ]: INFO: stdin is not coming from the terminal
[2024-12-28T08:08:27+09:00 ]: INFO: stdin is coming from a pipe
[2024-12-28T08:08:27+09:00 ]: INFO: /dev/stdin -> /proc/10763/fd/pipe:[240561]
bash,10751 src/stdin/loop_from_stdin.sh
  └─bash,10753 /dev/fd/63
      ├─bash,10755 src/stdin/loop_from_stdin.sh
      │   └─sleep,10757 1
      └─pstree,10764 -a -p 10751
[2024-12-28T08:08:27+09:00 ]: /dev/stdin: 1
[2024-12-28T08:08:28+09:00 ]: /dev/stdin: 2
[2024-12-28T08:08:30+09:00 ]: /dev/stdin: 3

--- Read lines from argv[1] ---
[2024-12-28T08:08:33+09:00 ]: INFO: ARGC=2, ARGS=[/dev/fd/62 /dev/fd/61]
[2024-12-28T08:08:33+09:00 ]: INFO: stdin is not coming from the terminal
[2024-12-28T08:08:33+09:00 ]: INFO: stdin is not coming from a pipe
[2024-12-28T08:08:33+09:00 ]: INFO:/dev/stdin -> /dev/null
[2024-12-28T08:08:33+09:00 ]: /dev/fd/62 -> /proc/10852/fd/pipe:[241564]
[2024-12-28T08:08:33+09:00 ]: /dev/fd/61 -> /proc/10854/fd/pipe:[241565]
bash,10751 src/stdin/loop_from_stdin.sh
  ├─bash,10838 src/stdin/loop_from_stdin.sh
  │   └─sleep,10842 1
  ├─bash,10839 src/stdin/loop_from_stdin.sh
  │   └─sleep,10843 1
  └─bash,10840 /dev/fd/63 /dev/fd/62 /dev/fd/61
      └─pstree,10855 -a -p 10751
[2024-12-28T08:08:33+09:00 ]: $1=/dev/fd/62: a
[2024-12-28T08:08:34+09:00 ]: $1=/dev/fd/62: b
[2024-12-28T08:08:34+09:00 ]: $2=/dev/fd/61: A
[2024-12-28T08:08:35+09:00 ]: $2=/dev/fd/61: B
[2024-12-28T08:08:35+09:00 ]: $1=/dev/fd/62: c
[2024-12-28T08:08:36+09:00 ]: $2=/dev/fd/61: C
----

* Example 5: `read_from_tty.sh`
+
[source,plaintext]
.Result 1: Input from terminal
----
$ bash read_from_tty.sh
Enter the some word: aaaa
Output: aaaa
----
+
[source,plaintext]
.Result 2: Input from PIPE
----
$ bash src/stdin/read_from_tty.sh < <(echo -n "Hello"; sleep 1; echo " world!")
Output: Hello world!
----
